# GC

## 如何判断垃圾

### 引用计数法

> 当一个对象被引用一次，就在对象头的一块内存中将该对象的引用计数（RC）+1，当RC=0时，表明该对象可以被垃圾回收器收集。**这种方式简单，高效，但是当对象之间存在循环引用的时候，根据引用计数法无法标记该对象是可以被回收的。**

### 可达性分析法

> 以一些GC ROOT对象为起点向下搜索，搜索走过的路径称为引用链（Reference Chain），当一个对象到GC ROOT没有任何引用链可达时，证明该对象不可达（不可用）。**可以被垃圾回收器收集。成功解决了引用计数器无法解决的问题--循环引用。**

+ **哪些对象可以作为GC ROOT的对象**：

  + 虚拟机栈中（栈帧中本地变量表）的本地变量

  + 方法区类静态属性引用的对象

  + 方法区常量引用的对象

  + 本地方法栈中中JNI（一般说的native方法）引用的对象

### 相关算法

+ 标记-清除
  + 将需要回收的垃圾对象标记，然后清除。简单，粗暴，停顿时间少，但是会产生大量内存碎片，不利于后续需要连续内存的大对象分配空间。（需要回收的对象越多，耗时越久）
+ 复制
  + 将存活的对象复制到内存中的另一块区域，然后将原来的区域中的对象全部清除。不会产生内存碎片，但是会有一部分空间处于不可用状态。
+ 标记-整理
  + 将存活的对象标记，然后向一端移动，在清除掉边界以外的内存区域。不会产生内存碎片，也规避了复制算法只使用一部分内存的问题，但是需要频繁移动存活对象的内存地址，效率低。（吞吐量高）

### 分代收集算法

#### 内存划分

> 新生代（Eden）：老年代（Old）= 
>
> Eden：Survivor1：Survivor2 = 8:1:1

+ Eden区垃圾回收

  + 采用复制算法，因为新生代垃圾对象很多，因此采用复制算法，（首次Minor GC）将存活的少量对象复制到其中一个Survivor区，另一Survivor区保持未使用状态，然后将Eden区清空，之后的Minor GC，将Eden区存活的对象及Survivor区的存活对象复制到另外一个Survivor区（如果空白的Survivor区不够分配空间，那么直接进入Old区），对象每从一个Survivor复制到另外一个Survivor时，该对象的分点年龄+1，经过16次Minjor GC后仍然存活的对象，就会进入老年代。

+ Old区垃圾回收

  + 因为Old区的存活对象很多，因此Major GC的时候采用标记整理算法，这样可以避免产生内存碎片，且空间可以充分利用。

  