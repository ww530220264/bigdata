[toc]

# **锁**

## CAS

> 底层实现指令: Lock cmpxchg 	(compare and exchange)
>
> 加lock的原因是,保证compare和exchange两个操作是原子的,也就是在对一块内存做compareAndSet操作的时候，会对这块内存上锁,不允许别的CPU打断

> lock执行后面指令的时候锁定一个北桥信号(而不采用锁总线)

## 用户态和内核态

> 内核能访问所有的操作系统指令，用户态只能访问能访问的执行，Intel指令分为ring0--ring3级，Linux内核工作在ring0级，能访问所有的指令，Linux用户态工作在ring3级，不能访问某些直接的指令。而JVM工作在用户态，锁的资源需要通过操作系统才能申请到，申请资源必须通过kernal（内核态）系统调用（0X80指令），获取到锁后还要通过操作系统将锁信息返回给jvm，所以早期JDK的synchronized是重量级锁）。

> 现在对synchronized做了一些优化，在某些状态下，不需要向操作系统申请资源，通过用户空间（锁）就能解决问题。

## 对象内存布局

> 可以使用工具包jol

## MarkWord

> <u>**给对象上锁，就是修改对象的markword**</u>

+ 锁信息

  + 偏向锁

  + 轻量级锁

  + 重量级锁

+ gc信息[分代年龄]

+ hashcode

### 类型指针：class pointer

> [指向T.class]（4个字节）

### 成员数据：instance data

> [实例数据|成员数据]

### 字节对齐：byte for alignment

> (用作字节对齐,每8个字节)

##   锁升级

<img src=".\image\Hotspot_MarkWord.png" alt="image-20200421162649398" style="zoom:200%;" />

### <img src=".\image\锁升级.png" alt="image-20200421162649398" style="zoom:200%;" />



![image-20200421164803118](C:\Users\53022\Desktop\笔记\JVM\image\升级步骤.png)

> 偏向锁和轻量级锁(自旋锁)都是用户空间的锁，省去了和操作系统打交道的一环，所以是比较轻量的。

### **为什么会有锁升级**

> 在实际调查过程中，发现,synchronized代码在大多数情况下只有一个线程在调用，所以在这种情况下，没必要设置竞争机制。

### 偏向锁

> 没有线程竞争，仅仅把当前线程ID写入到对象的markword中，这样效率很高。

### 轻量级锁（自旋锁）

> 有线程竞争锁的话，就先把**偏向锁撤销**，然后两个线程通过自旋的方式竞争，两个线程分别在自己的线程栈中生成一个LR（Lock Record），通过自旋将对象的markword中的一个指针指向自己的LR，没有成功的那个线程通过CAS自旋来继续竞争。

**为什么有了自旋锁还要有重量级锁**

> 自旋是会消耗cpu资源的，当锁被持有的时间长，自旋的线程数量多了以后，cpu会被大量消耗；而重量级锁有等待队列（waitset），所有等待锁的线程会进入等待队列，不需要消耗cpu资源。
>
> jdk1.6之前默认线程自旋超过10次，或者自旋的线程个数超过了cpu核数的一半，就会把轻量级锁升级为重量级锁，1.6只有，有了自适应调整，不需要手动调整。

**偏向锁不一定比自旋锁效率高**

> 当只有一个线程使用的时候，效率是最高的，当有其他线程竞争时，会涉及到偏向锁撤销、锁升级的操作，效率较低；当明确知道有多线程竞争时，应该使用自旋锁，因为肯定会涉及到锁撤销。
>
> 默认情况下，偏向锁启动有时延：默认4s
>
> -XX:BiasedLockingStartupDelay=4
>
> eg:	jvm启动的时候，会有很多线程竞争（明确），这些代码启动的时候肯定会存在竞争,因此默认情况下不打卡偏向锁，过一会再打卡。

### Synchronized锁可重入

+ 锁被线程重入时，在线程栈中生成一个LR（lock record）记录来记录锁的信息，当锁被释放的时候，线程栈就会弹出一个LR来以此对应

+ 向操作系统申请重量级锁之后，锁的信息会记录在monitorenter的一个字段中。

+ synchronized关键字会在代码块开始加上**monitorenter**指令，在代码块结束位置会加上**monitorexit**指令，在有异常的位置也会加上**monitorexit**指令。