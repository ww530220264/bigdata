[toc]

# **锁**

## CAS

> 底层实现指令: Lock cmpxchg 	(compare and exchange)
>
> 加lock的原因是,保证compare和exchange两个操作是原子的,也就是在对一块内存做compareAndSet操作的时候，会对这块内存上锁,不允许别的CPU打断

> lock执行后面指令的时候锁定一个北桥信号(而不采用锁总线)

## 用户态和内核态

> 内核能访问所有的操作系统指令，用户态只能访问能访问的执行，Intel指令分为ring0--ring3级，Linux内核工作在ring0级，能访问所有的指令，Linux用户态工作在ring3级，不能访问某些直接的指令。而JVM工作在用户态，锁的资源需要通过操作系统才能申请到，申请资源必须通过kernal（内核态）系统调用（0X80指令），获取到锁后还要通过操作系统将锁信息返回给jvm，所以早期JDK的synchronized是重量级锁）。

> 现在对synchronized做了一些优化，在某些状态下，不需要向操作系统申请资源，通过用户空间（锁）就能解决问题。

## 对象内存布局

> 可以使用工具包jol

## MarkWord

> <u>**给对象上锁，就是修改对象的markword**</u>

> 锁信息

### **锁信息**

* 偏向锁
* 轻量级锁
* 重量级锁

> gc信息[分代年龄]

> hashcode

### class pointer

> [指向T.class]（4个字节）

### instance data

> [实例数据|成员数据]

### byte for alignment

> (用作字节对齐,每8个字节)

##   锁升级

<img src=".\image\Hotspot_MarkWord.png" alt="image-20200421162649398" style="zoom:200%;" />

### <img src=".\image\锁升级.png" alt="image-20200421162649398" style="zoom:200%;" />



![image-20200421164803118](C:\Users\53022\Desktop\笔记\JVM\image\升级步骤.png)

> 偏向锁和轻量级锁(自旋锁)都是用户空间的锁，省去了和操作系统打交道的一环，所以是比较轻量的。

### **为什么会有锁升级**

> 在实际调查过程中，发现,synchronized代码在大多数情况下只有一个线程在调用，所以在这种情况下，没必要设置竞争机制。

### 偏向锁

> 没有线程竞争，仅仅把当前线程ID写入到对象的markword中，这样效率很高。

### 轻量级锁（自旋锁）

> 有线程竞争锁的话，就先把**偏向锁撤销**，然后两个线程通过自旋的方式竞争，两个线程分别在自己的线程栈中生成一个LR（Lock Record），通过自旋将对象的markword中的一个指针指向自己的LR，没有成功的那个线程通过CAS自旋来继续竞争。